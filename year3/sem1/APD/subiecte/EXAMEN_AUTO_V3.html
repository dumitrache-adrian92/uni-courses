<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
    <style>
    .btn {
    padding: 10px;
    }
    .btn.active:focus,
    .btn:active:focus,
    .btn:focus {
    outline: 0;
    box-shadow: none;
    }
    .btn,
    .btn-block {
    white-space: normal;
    }
    div {
        padding-bottom: 8px;
        padding-top: 8px;
        border-top: 2px solid grey;
    }
    .question {
        padding: 10px;
        pointer-events: none;
        border-radius: 25px;
        background-color: #fff;
        color: #000;
        outline: 0;
    }

    .filterDiv {
        padding: 2px;
        border-top: 0px solid grey;
    }

    </style>
</head>
<body>




    <script>
        document.body.onload = addElement;
        function addElement() {
var QUESTIONS={"Ce inseamna un “split binary semaphore”?":{options:["nu exista acest termen","un semafor care poate avea valori intre o si N","un semafor care poate avea valori de 0 sau 1","un grup de semafoare care au suma valorilor cel mult egala cu 1"],answer:"un grup de semafoare care au suma valorilor cel mult egala cu 1"},"Care dintre urmatoarele afirmatii este falsa in cadrul problemei cititori - scriitori?":{options:["Un cititor nu poate citi in timp ce un scriitor scrie","Un singur cititor are dreptul sa citeasca la un moment dat","Mai multi cititori au dreptul sa citeasca simultan","Un singur scriitor are dreptul sa scrie la un moment dat"],answer:"Un singur cititor are dreptul sa citeasca la un moment dat"},"Implementarea Java Thread face ca toate thread-urile sa se execute pe un singur CPU indiferent de cate procesoare are masina pe care ruleaza / Folosind Java Threads programatorul poate crea mai multe thread-uri decat numarul de CPU-uri de pe masina":{options:["fals / adevarat","adevarat / adevarat","adevarat / fals","fals / fals"],answer:"fals / adevarat"},"In Java folosim synchronized pentru a marca o zona critica / In Pthread folosim pthread_barrier_t pentru a marca o zona critica":{options:["adevarat / fals","adevarat / adevarat","fals / fals","fals / adevarat"],answer:"adevarat / fals"},"Care este rezultatul apelarii metodei .run() a unui thread Java?":{options:["Deadlock, indiferent de felul in care este definita clasa MyThread.","Generarea unei exceptii de tipul InvalidCallException.","Executia, pe firul curent, a continutului metodei.","Pornirea unui nou thread care va executa Runnable-ul definit de catre clasa."],answer:"Executia, pe firul curent, a continutului metodei."},"Ce face MPI_Comm_rank?":{options:["Returneaza numarul de procese active","Returneaza numarul total de procese","Returneaza rank-ul procesului curent","Trimite un mesaj de la un proces x pana la un proces y"],answer:"Returneaza rank-ul procesului curent"},"Cu ce difera ipoteza algoritmului Hirschberg - Sinclair de cea a agloritmilor LeLann si LeLann-Chang-Robert?":{options:["exista un lider cunoscut a priori","procesele pot sa se transmita bidirectional","procesele sunt grupate intr-o topologie arbore","mai multe procese pot deveni lideri"],answer:"procesele pot sa se transmita bidirectional"},"In MPI cum se primesc mesajele trimise prin apelul functiei MPI_Bcast?":{options:["Prin apel MPI_Send","Prin apel MPI_Recv","Prin apel MPI_Get","Prin apel MPI_Bcast"],answer:"Prin apel MPI_Bcast"},"Alegerea liderului cu algoritmul arbore:":{options:["radacina arborelui initiaza algortimul de alegere","doar frunzele pot initia faza de wake-up","fiecare nod isi seteaza mai intai un parinte","un proces incepe algoritmul de alegere dupa ce primeste wake-up pe fiecare canal"],answer:"un proces incepe algoritmul de alegere dupa ce primeste wake-up pe fiecare canal"},"Algoritmul Pulsatiilor: Care este complexitatea in timp?":{options:["O(N)","O(D*logN)","O(D)","O(D*N)"],answer:"O(D)"},"Care este complexitatea inmultirii a doua matrici in paralel?":{options:["O(N3/P)","O(N2/P)","O(N)","O(N*P)"],answer:"O(N3/P)"},"In practica, timpul de executie scade intotdeuna liniar cu numarul de procesoare. / Inmultirea de matrici este un exemplu de algoritm careNU poate fi paralelizat.":{options:["adevarat / fals","adevarat / adevarat","fals / fals","fals / adevarat"],answer:"fals / fals"},"In pthread, alocarea de cuante de timp pe CPU pentru thread-uri se face de catre:":{options:["MMU","Sistemul de Operare","Compilator","Programator"],answer:"Sistemul de Operare"},"Execuția in paralel a operației logice a|b (unde a si b sunt doua numere întregi) este un exemplu de paralelism la nivel de:":{options:["instructiune","bit","CPU","task"],answer:"bit"},"Clock drift (deplasarea unui ceas) reprezinta":{options:["frecventa cu care oscileaza ceasul unui calculator","diferenta dintre ceasul local al unui calculator si un ceas de referinta","diferenta dintre timpul cand se genereaza o intrerupere si timpul cand se incarca informatia in registru","diferenta de timp intre mai multe calculatoare"],answer:"diferenta dintre ceasul local al unui calculator si un ceas de referinta"},"In cazul solutiei lui Lamport, fiecare proces la prornire isi initializeaza ceasul logic cu":{options:["1","timpul sistemului distribuit","timpul fizic curent","0"],answer:"0"},"Considerând următorul pseudo-cod: chan Can (int); process P1{ int v1 =0; v1 = v1+7; (ev1) send Can(v1);} (ev2) process P2{ int v2 =0; v2 = v2+1; (ev3) receive Can(v2); (ev4) v2++;} (ev 5)Se poate garanta ca pentru orice execuție:":{options:["evenimentele ev2 si ev5 sunt concurente","evenimentele ev1 si ev4 sunt concurente","evenimentele ev2 si ev3 sunt concurente","evenimentele ev2 si ev4 sunt concurente"],answer:"evenimentele ev2 si ev3 sunt concurente"},"Folosind tehnica de semafor splitat (split binary semaphore) in problema Cititori-Scriitori, se ofera prioritate:":{options:["la scriitori","la cititori","nu se ofera nici o prioritate","atat la cititori cat si la scriitori"],answer:"atat la cititori cat si la scriitori"},'Doua thread-uri au o variabila partajata "int a = 0". Daca fiecare thread executa in paralel (si fara sincronizare) operatia "a++", ce rezultate se pot obtine la finalul rularii celor doua thread-uri?':{options:["1 sau 2","2","0 sau 1 sau 2","0 sau 2"],answer:"1 sau 2"},"Un exemplu de defect de tip omisiune:":{options:["un proces raspunde inafara unui interval de timp setat in algoritm","un proces nu reuseste sa mai trimita un mesaj, datorita incarcarii procesorului","un proces se restarteaza","un proces trimite mesaje cu continut arbitrar"],answer:"un proces nu reuseste sa mai trimita un mesaj, datorita incarcarii procesorului"},"Metoda folosita pentru inchiderea unui Executor Service (oprirea tututor task-urilor active) in Java este:":{options:[".exit()",".join()",".shutdownNow()",".close()"],answer:".shutdownNow()"},"Intr-un program Pthread, o variabila declarata global poate fi vazuta de toate thread-urile / Intr-un program Pthread, o variabila declarata global poate fi modificata de toate thread-urile":{options:["A / F","A / A","F / A","F / F"],answer:"A / A"},"Semaforul in programarea paralela NU poate fi folosit pentru:":{options:["schimbul sincron de valori intre thread-uri","protejarea unei regiuni critice","contorizarea accesului la o resursa partajata","ordonarea executiei intre thread-uri"],answer:"ordonarea executiei intre thread-uri"},"Un sistem distribuit care pica o milisecunda la fiecare ora:":{options:["este disponibil, dar non-fiabil","este si fiabil si disponibil","nu e nici disponibil, nici fiabil","este fiabil, dar non-disponibil"],answer:"este disponibil, dar non-fiabil"},"Cum se porneste un thread in Pthread?":{options:["apel pthread_start()","#pragma omp parallel","apel pthread_create()","apel pthread()"],answer:"apel pthread_create()"},"Problema filozofilor reprezinta o situatie in care se paote ajunge la …":{options:["deadlock","livelock","race condition","starvation"],answer:"deadlock"},"Minim de cate semafoare este nevoie pentru a rezolva problema bărbierului? (Se considera cele 3 constrangeri ale problemei discutate la curs: barbierul fara clienti, venirea unui client, respectiv frizerie plina)":{options:["2","4","3","1"],answer:"3"},"Care este un dezavantaj la soluția Reader priority (prioritate Cititorilor) pentru problema Cititori si Scriitori?":{options:["exista posibilitatea ca cititorii sa nu mai aibă ce citii","cititorii pot citi valori greșite","un flux continuu de cititori pot bloca ulterior pe toți potențialii scriitori","niciun scriitor nu va putea modifica niciodată resursa comuna"],answer:"un flux continuu de cititori pot bloca ulterior pe toți potențialii scriitori"},"Care este una dintre diferențele dintre un semafor binar si un mutex?":{options:["semaforul binar oferă siguranță la ștergere, task-ul care deține semaforul binar nu pate fi șters (însă nu si mutex-ul)","daca un task care deține semaforul binar se termina din diferite motive, SO poate reda resursa semaforului (însă nu si la mutex)","nu exista nici o diferența","apare eroare daca un task care nu deține mutexul încearcă sa îl elibereze (însă nu si la semafor binar)"],answer:"apare eroare daca un task care nu deține mutexul încearcă sa îl elibereze (însă nu si la semafor binar)"},"Ce inseamna excludere mutuala?":{options:["doar un proces poate fi la un moment dat intr-o regiune critica","maxim 3 procese pot fi la un moment dat intr-o regiune critica","procesele trebuie sa intre intr-o sectiune critica intr-o anumita ordine","niciun proces nu poate fi vreodata intr-o sectiune critica"],answer:"doar un proces poate fi la un moment dat intr-o regiune critica"},"Care este diferenta dintre mutex si semafor binar?":{options:["mutexul are constrangeri aditionale, impuse chiar la nivelul sistemului de operare","valoarea asociata semaforului binar poate fi >1","sunt acelasi lucru"],answer:"mutexul are constrangeri aditionale, impuse chiar la nivelul sistemului de operare"},'Cand avem in Java o metoda de tipul "public synchronized void f()" intr-o clasa C, pe monitor lock-ul carui obiect se face sincronizarea?':{options:["f","this","C.class","un obiect nou creat special"],answer:"this"},"Avem un program cu un deadlock:":{options:["se va bloca intotdeauna","uneori se va bloca la nesfarsit","nu va compila","va termina mereu executarea afisand rezultatul corect"],answer:"uneori se va bloca la nesfarsit"},"Problema filosofilor este un exemplu clasic de problema pentru:":{options:["Alegerea liderului","Deadlock","Stabilirea topologiei","Nimic"],answer:"Deadlock"},"Alegeți afirmația incorecta referitor la tehnica Split binary semaphore:":{options:["Instrucțiunile între operațiile P (luare resursa) și V (eliberare resursa) se execută în excludere mutuală","Fiecare cale de execuție începe cu o operație P (luare resursa) pe unul dintre semafoare din set și se termină cu o operație V (eliberare resursa) pe respectivul semafor","Întotdeauna, cel mult unul dintre semafoarele din set este 1","Inițial unul dintre semafoare din set este 1"],answer:"Fiecare cale de execuție începe cu o operație P (luare resursa) pe unul dintre semafoare din set și se termină cu o operație V (eliberare resursa) pe respectivul semafor"},"In problema Producători și consumatori, M Producători, N Consumatori si k dimensiune buffer, de cate semafoare este nevoie pentru implementare, daca nu se mai poate folosi nici un alt mecanism de sincronizare?":{options:["4","3","2","1"],answer:"4"},"Considerand problema filosofilor cu 4 filosofi, cate furculite sunt asezate pe masa?":{options:["3","4","5","8"],answer:"4"},"Cum se poate delimita o zona critica in Java?":{options:["Folosind pthread_lock()/pthread_unlock()","Folosind o bariera ciclica","Folosind synchronized","Folosind o bariera"],answer:"Folosind synchronized"},"Un thread poate fi creat implementand interfata Runnable / Thread-urile sunt pornite apeland metoda thread.start()":{options:["fals / adevarat","adevarat / adevarat","adevarat / fals","fals / fals"],answer:"adevarat / adevarat"},"Care este diferenta dintre metodele run() si start() ale unui obiect de tip Thread in Java?":{options:["start() va crea un thread nou care va rula metoda run()","run() este folosit pentru a porni un thread in cazul in care am creat clasa noastra implementand interfata Runnable","run() va rula metoda start() intr-un thread separat","Nu exista nicio diferenta"],answer:"start() va crea un thread nou care va rula metoda run()"},"Ce inseamna ca un lock este re-entrant?":{options:["Daca un thread a luat deja lock-ul respectiv, va putea sa-l ia de oricate ori cat timp il detine","Mai mult thread-uri pot sa intre in regiunea critica delimitata de acel lock","Un thread care detine lock-ul se va bloca daca va incerca sa-l ia din nou","Niciun thread nu poate sa intre in regiunea critica delimitata de acel lock"],answer:"Daca un thread a luat deja lock-ul respectiv, va putea sa-l ia de oricate ori cat timp il detine"},'Avem un semafor in Java declarat cu "Semaphore s = new Semaphore(-2)". De cate "s.release()" este nevoie astfel incat un thread care apeleaza "s.acquire()" sa se deblocheze din asteptare?':{options:["2","1","0","3"],answer:"3"},"Care este semnificatia unei sectiuni synchronized in Java?":{options:["Sectiunea synchronized nu trebuie deloc executata","Mai multe thread-uri pot executa sectiunea synchronized la acelasi moment de timp","Un singur thread poate executa sectiunea synchronized la acelasi moment de timp","In Java nu exista conceptul de synchronized"],answer:"Un singur thread poate executa sectiunea synchronized la acelasi moment de timp"},"Apelul this.wait() intr-o metoda non-statica sincronizata produce exceptie / In Java se poate initializa un Semaphore cu o valoare negativa (corespunzator numarului de permise)":{options:["A / F","A / A","F / A","F / F"],answer:"F / A"},"De ce poate aparea exceptia IllegalMonitorStateException in Java atunci cand apelam wait() pe un obiect?":{options:["Thread-ul curent a fost intrerupt","Obiectul respectiv nu a fost alocat","Thread-ul curent nu detine monitor lock-ului obiectului pe care apelam wait()","Nu a apelat nimeni notify() intr-o perioada data de timp"],answer:"Thread-ul curent nu detine monitor lock-ului obiectului pe care apelam wait()"},"In Java, ce face metoda submit(Runnable task) din ExecutorService?":{options:["Creeaza un nou task in thread pool","Creeaza un nou thread pool, in care vom avea task-ul respectiv","Submite task-ul dat ca parametru in thread pool","Porneste executia tuturor task-urilor din thread pool"],answer:"Submite task-ul dat ca parametru in thread pool"},"In Java notify() pune un thread din starea waiting in running / notifyAll() trezeste toate threadurile din waiting, punandu-le in running":{options:["adevarat / adevarat","adevarat / fals","fals / adevarat","fals / fals"],answer:"adevarat / adevarat"},'Considerati in Java clasa A ce are definita o metoda statica astfel: "public static synchronized f() {...}" ? Cum se realizeaza sincronizarea in acest caz?':{options:["Pe obiectul 'this'","La nivel de clasa A","Intre toate metodele statice din orice obiect de tipul A","Intre toate metodele f din obiecte diferite de tipul A"],answer:"La nivel de clasa A"},"Care este costul pentru Cautarea binara Paralela -  varianta 2 (original pentru SIMD - CREW) ?":{options:["O(log (P+1)(N+1))","O(log2N / log (P+1)(N+1))","O(P * log (P+1)(N+1))"],answer:"O(P * log (P+1)(N+1))"},"Care este condiția pentru adăugarea unei noi regine (la problema Reginelor)? Oricare doua regine nu trebuie sa fie:":{options:["pe aceeași linie, coloana, diagonala principala sau secundara","pe aceeași linie, coloana sau diagonala principala","pe aceeași linie sau coloana","pe aceeași linie, coloana sau diagonala secundara"],answer:"pe aceeași linie, coloana, diagonala principala sau secundara"},"De cate procese este nevoie pentru implementarea calcului polinomial cu Pipeline, considerând ca ultima putere a lui x este 6:":{options:["cel mult 7, se vor împarți in mod egal coeficienții","1 proces","cel mult 6, se vor împarți in mod egal coeficienții","exact 6, fiecare proces poate sa aibă exact un coeficient"],answer:"cel mult 7, se vor împarți in mod egal coeficienții"},"Care este complexitatea algoritmului de Căutare binara paralela in sistemele SIMD - EREW (Exclusive Read Excusilve Write)? Se considera P procesoare si o secvență ordonata de N numere.":{options:["O(NlogN)","O(logN)","O(logP)","O(log(N/P)"],answer:"O(logN)"},"Alegeți varianta ce nu reprezintă un pas in Sortarea (crescătoare) folosind Pipeline. Primul proces (Rank 0) va primi rând pe rând cate un element. Fiecare proces:":{options:["va transmite spre ieșire (Rank 0) o valoare primita de la vecinul din dreapta","compară valoarea cu cea memorata local","acceptă o valoare de la vecinul din stânga","transmite valoarea mai mica vecinului din dreapta"],answer:"transmite valoarea mai mica vecinului din dreapta"},"Algoritmul lui Dekker functioneaza doar pentru 2 thread-uri/procese?":{options:["Adevarat","Fals"],answer:"Adevarat"},"Ce reprezinta “starvation” in contextul lucrului paralel cu thread-uri?":{options:["Niciun progres nu se face la nivel de aplicatie","Un thread asteapta indefinit sa ia resursa pentru a rula","Un thread lasa “lock” si asteapta dupa celelalte"],answer:"Un thread asteapta indefinit sa ia resursa pentru a rula"},"Care este complexitatea temporala a difuzarii paralele a unei valori, pentru P = N / 2?":{options:["O(log2N)","O(N2)","O(N)","O(N * log2N)"],answer:"O(log2N)"},"In sisteme SIMD nu este nevoie ca programatorul sa foloseasca mecanismul de bariera.":{options:["Adevarat","Fals"],answer:"Adevarat"},"Care este complexitatea pentru a calcula (eficient) in paralel distanta din fiecare punct al unei liste pana la sfarsitul acesteia? Lista are N elemente.":{options:["O(logN)","O(NlogN)","O(N)","O(N2)"],answer:"O(logN)"},"Care este complexitatea Parallel Merge Sort? (atentie exista si varianta P=N)":{options:["O(n2)","O(n * log n)","O(n)","O(log n2)"],answer:"O(log n2)"},"Ce complexitate are cautarea paralela pe un vector cu N elemente si un sistem cu N/2 procesoare?":{options:["O(1)","O(N)","O(log(log(N)))","O(log(N))"],answer:"O(1)"},"Consideram un sistem cu n procesoare pe care dorim sa realizam in paralel suma partiala a elementelor unui vector ce contine n elemente. Sumele partiale se vor stoca la nivelul fiecarui proces. Care este regula ca la un anumit pas (j) un proces sa lucreze? (j porneste cu valoarea 1)":{options:["rank_proces - pow(2,j-1) >= 1","rank_proces - pow(2,j) < 1","rank_proces - pow(2,j) >= 1","rank_proces mod pow(2,j) == 0"],answer:"rank_proces - pow(2,j-1) >= 1"},"Considerati urmatorul cod pentru sumele prefix, executat pe un sistem MIMD: process suma[k=1 to n] {    for (j = 1; j < sup(log2 n); j++) {        temp[k] = a[k];        if (k - 2j-1 >= 1)            a[k] = temp[k-2j-1] + a[k];    }}Este nevoie sa se adauga mecanisme de sincronizare?":{options:["Da, 1 mutex","Da, 2 bariere","Da, 1 bariera","Nu"],answer:"Da, 2 bariere"},"Considerati urmatorul cod pentru sumele prefix, executat pe un sistem SIMD: process suma[k=1 to n] {    for (j = 1; j < sup(log2 n); j++) {        temp[k] = a[k];        if (k - 2j-1 >= 1)            a[k] = temp[k-2j-1] + a[k];    }}Este nevoie sa se adauga mecanisme de sincronizare?":{options:["Da, 1 mutex","Da, 2 bariere","Da, 1 bariera","Nu"],answer:"Nu"},"Care este complexitatea de difuzare a unei valori intr-un sistem SIMD - EREW cu P procesoare?":{options:["O(logP)","1","O(PlogP)","O(P)"],answer:"O(logP)"},"In cadrul modelului genetic Master-Slave,":{options:["functia de fitness se evalueaza in paralel si operatorii de selectie si evolutie se aplica pe sub-populatii","functia de fitness se evalueaza la nivelul masterului si operatorii de selectie si evolutie se aplica pe toata populatia","functia de fitness se evalueaza la nivelul masterului si operatorii de selectie si evolutie se aplica pe sub-populatii","functia de fitness se evalueaza in paralel si operatorii de selectie si evolutie se aplica pe toata populatia"],answer:"functia de fitness se evalueaza in paralel si operatorii de selectie si evolutie se aplica pe toata populatia"},"In cadrul Selecției de tip turneu:":{options:["Se aleg soluțiile (cromozomii) cele mai bune pentru etapa următoare","Se aleg soluții (cromozomi) doua cate doua, soluția mai buna este aleasa","Soluțiile (cromozomii) se aleg in funcție de rank-ul lor","Fiecare soluție (cromozom) are o probabilitate de a fi aleasa, proporțională cu valoarea sa de fitness"],answer:"Se aleg soluții (cromozomi) doua cate doua, soluția mai buna este aleasa"},"Care este rezultatul operației de Crossover in doua puncte, după poziția a4a si a9a pentru următorii 2 cromozomi:Cromozom1: 1101 | 00100 | 110100Cromozom2: 1010 | 11000 | 011110":{options:["Descendent1: 1010 00100 011110Descendent2: 1101 11000 110100","Descendent1: 1000 00100 011110Descendent2: 1111 11000 110100","Descendent1: 1011 00100 011110Descendent2: 1100 11000 110100","Descendent1: 1010 11000 110100Descendent2: 1101 00100 011110"],answer:"Descendent1: 1010 00100 011110Descendent2: 1101 11000 110100"},"Atunci cand se intoarce, apelul MPI_Send indica faptul ca:":{options:["Receptorul a apelat MPI_Recv si a inceput sa receptioneze datele in cadrul programului MPI","Receptorul a apelat MPI_Recv si a receptionat integral datele in programul MPI","Informatia a ajuns in bufferele receptorului","Informatia a fost copiata in bufferele de trimitere"],answer:"Informatia a fost copiata in bufferele de trimitere"},"Ce face MPI_Comm_size?":{options:["Face broadcast in toata reteaua de procese","Returneaza numarul de procese asociate cu un comunicator","Returneaza rangul procesului curent","Trimite un mesaj de la un proces x pana la un proces y"],answer:"Returneaza numarul de procese asociate cu un comunicator"},"Ce se poate intampla daca facem foarte multe send-uri dintr-un proces MPI, dar nu facem recv in procesul destinatie?":{options:["Primele mesaje trimise se vor pierde","Nimic notabil","Operatia de send poate deveni blocanta la umplerea bufferului de sistem","Vom primi un buffer overflow"],answer:"Operatia de send poate deveni blocanta la umplerea bufferului de sistem"},"In cazul modelului distribuit  de pasare a mesajelor, canalele de comunicare trebuie sa garanteze ca:":{options:["pot comunica doar in mod sincron","mesajele nu se vor pierde","mesajele vor ajunge la procesul destinatie, chiar daca nu in ordinea de trimitere"],answer:"mesajele nu se vor pierde"},"In modelul distribuit de comunicare prin pasarea mesajelor:":{options:["se garantează ca mesajele trimise pe canal nu se vor pierde","memoria este grupată și partajabilă între procese","se garantează respectarea ordinii de trimitere doar daca procesele comunica in mod sincron","nu se garantează ca doua mesaje trimise unul după altul către aceeași destinație vor ajunge la procesul destinatar respectând ordinea de trimitere"],answer:"se garantează ca mesajele trimise pe canal nu se vor pierde"},"Care dintre urmatoarele afirmatii despre modelul de comunicare sincrona prin mesaje este adevarata?":{options:["operatia send este blocanta","operatia send nu este blocanta","canalele pot pierde mesaje","operatia receive nu este blocanta"],answer:"operatia send este blocanta"},"MPI este un standard pentru programarea multi-thread / MPI vine de la Message Passing Interface.":{options:["adevarat / fals","adevarat / adevarat","fals / fals","fals / adevarat"],answer:"fals / adevarat"},"In cadrul modelului Foster de calcul al complexitatii algoritmilor distribuiti, ce reprezinta S in formul:  Tmsg-b = ts + twSL":{options:["numarul de operatii send realizate","numarul de proceasoare ce comunica simultan pe acelasi canal in acelasi sens","acceleratia (speedup)","timpul de idle"],answer:"numarul de proceasoare ce comunica simultan pe acelasi canal in acelasi sens"},"In cadrul modelului LogP de calcul al complexitatii algoritmilor distribuiti, ce reprezinta “gap-ul”?":{options:["intarzierea de transmitere a unui mesaj mic de la sursa la destinatar","durata cand procesorul este angajat in transmiterea/receptia fiecarui mesaj","numarul de module procesor / memorie","intervalul minim dintre 2 transmiteri/ receptii succesive ale aceluiasi modul"],answer:"intervalul minim dintre 2 transmiteri/ receptii succesive ale aceluiasi modul"},"Care este varianta corecta de apel de MPI_SEND pentru o variabila int x =3?":{options:["MPI_SEND(&x, 1, MPI_INT);","MPI_SEND(&x, 1, MPI_INT, MPI_COMM_WORLD);","MPI_SEND(&x, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);","MPI_SEND(&x, 1, sizeof(int), 1, 0, MPI_COMM_WORLD);"],answer:"MPI_SEND(&x, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);"},"In MPI, care este scopul operatiei Scatter?":{options:["nu exista aceasta operatie in MPI","difuzarea unei valori catre toate procesele dintr-un comunicator","distribuirea unui array catre toate procesele dintr-un comunicator","colectarea unui array de la toate procesele dintr-un comunicator"],answer:"distribuirea unui array catre toate procesele dintr-un comunicator"},"Cum este definiti timpul total de executie al unul algoritm distribuit?":{options:["Timpul scurs de la inceperea executiei primului proces pana la terminarea executiei ultimului proces","Suma timpilor de executie a tuturor proceselor","Media dintre timpii de executie a tuturor proceselor","Timpul scurs de la terminarea executiei primului proces pana la inceperea executiei ultimului proces"],answer:"Timpul scurs de la inceperea executiei primului proces pana la terminarea executiei ultimului proces"},"Care din urmatoarele solutii de sincronizare pe baza de ceas este descentralizata?":{options:["nici o varianta listata aici","Algoritmul lui Cristian","Algoritmul lui Barkeley","Network Time Protocol (NTP)"],answer:"Network Time Protocol (NTP)"},"Considerand relatia de petrecut înainte (->) si doua evenimente a şi b:":{options:["dacă a -> b şi b -> c, atunci a -> c","dacă a şi b nu sunt din acelasi proces, nu se poate stabili o relatia intre ele","dacă a reprezintă transmiterea unui mesaj iar b recepţia aceluiaşi mesaj la destinatie, atunci b -> a","dacă a şi b sunt pe acelasi proces, nu se poate aplica aceasta relatie"],answer:"dacă a -> b şi b -> c, atunci a -> c"},"Care dintre urmatoarele este o solutie de ceas fizic centralizat?":{options:["NTP","Algoritmul Berkeley","Solutia lui Lamport"],answer:"Algoritmul Berkeley"},"Care este timpul de trimitere a unui mesaj intr-un sistem distribuit, unde timpul de serializare este de 30 unități, un caracter se trimite in 6 unități si dimensiunea mesajului este 8?":{options:["188","78","246","44"],answer:"78"},"Care este timpul de trimitere a unui mesaj intr-un sistem distribuit, unde timpul de serializare este de 20 unități, un caracter se trimite in 5 unități si dimensiunea mesajului este 7?":{options:["145","55","32","107"],answer:"55"},"In comunicarea intre procese, overhead-ul este definit ca:":{options:["durata pentru care procesorul este angajat în transmiterea sau recepția unui mesaj","cantitatea de resurse folosita de un nod de procesare in mediul distribuit","intervalul minim de timp cat un proces trebuie sa aștepte între două transmiteri succesive","întârzierea de transmitere a unui mesaj"],answer:"durata pentru care procesorul este angajat în transmiterea sau recepția unui mesaj"},"In cazul algoritmului arbore de alegere a liderului, numărul de mesaje trimise in sistem este:":{options:["2N","N - 2","4N","4N - 4"],answer:"4N - 4"},"Care este complexitatea (dpdv al numarului de mesaje transmise) algoritmului arbore de alegere a liderului cu N procese?":{options:["O(N)","O(1)","O(NlogN)","O(N2)"],answer:"O(N)"},"Pentru analiza unui algoritm paralel consideram: P=numar procesoare, T=timpul de executie a algoritmului paralel si G=timpul celui mai rapid algoritm secevential. Costul (C) reprezinta:":{options:["T * P","G / T * P","T * P / G","P * G"],answer:"T * P"},"Succesiunea a doua operatii atomice este atomica / Succesiunea a trei operatii atomice este atomica":{options:["A / A","A / F","F / A","F / F"],answer:"F / F"},"Algoritmul fazelor (heartbeat) este un algoritm unda:":{options:["Adevarat","Fals"],answer:"Adevarat"},"Numarul de mesaje pentru algoritmul LeLann este:":{options:["O(N^4)","O(N^3)","O(N^2)","O(N)"],answer:"O(N^2)"},"Numarul de mesaje pentru algoritmul LeLann-Chang-Robert, cazul cel mai favorabil, este: (atentie exista si cu cazul DEfavorabil)":{options:["2N-2","N(N+1)/2","N(N-1)/2","2N-1"],answer:"2N-1"},"Numarul de mesaje pentru algoritmul LeLann-Chang-Robert, cazul cel mai defavorabil, este: (atentie exista si cu cazul favorabil)":{options:["2N-2","2N-1","N(N+1)/2","N(N-1)/2"],answer:"N(N+1)/2"},"In cazul algoritmului Bully, un proces devine lider daca:":{options:["primeste OK de la majoritatea proceselor","trimite mesaje de Alegere si nu ii se raspunde","descopera primul ca actualul lider este picat","primeste OK de la toate proceselor"],answer:"trimite mesaje de Alegere si nu ii se raspunde"},"Care este numarul de mesaje pentru algoritmul LeLann-Chang-Robert, cazul cel mai bun (Procesele sunt ordonate crescator in sensula celor de ceasornic)? Obs.: Toate procesele sunt initiatoare.":{options:["N(N+1)","2N-1","N+1"],answer:"2N-1"},"Numarul de mesaje pentru algoritmul Hirschberg-Sinclair, cazul cel mai defavorabil, este:":{options:["O(logN)","O(NlogN)","O(N)","O(N2)"],answer:"O(NlogN)"},"Pe ce algoritm secvential de sortare se bazeaza Odd Even Transposition Sort?":{options:["Insertion sort","Merge sort","Bubble sort","Quick sort"],answer:"Bubble sort"},"In cazul algoritmului unda de tip arbore cu N noduri, numărul de mesaje trimise in sistem este:":{options:["N2","N","2N","N+2"],answer:"N"},"In cazul algoritmului unda de tip arbore cu N noduri, timpul de execuție este:":{options:["O(N)","O(N2)","O(D)","O(logN)"],answer:"O(D)"},"In cazul algoritmului unda de tip inel cu N noduri, timpul de execuție este:":{options:["O(N)","O(1)","O(logN)","O(N2)"],answer:"O(N)"},"In cautarea binara in varianta paralela (solutia optimizata), numarul de pasi (sau iteratii) necesari acoperirii intregului vector se face cautarea (notat cu g) este:":{options:["sup(log(n-1)/log(P))","sup(log(n+1)/log(P+1))","sup(log(p)/log )","sup(log /log(p))"],answer:"sup(log(n+1)/log(P+1))"},"La care dintre urmatorii algoritmi de tipa unda este necesar cunoasterea diametrului retelei?":{options:["algoritmul fazelor","algoritmul ecou","algoritmul arbore"],answer:"algoritmul fazelor"},"La replicarea cu lider (cvorum), cate procese indisponibile putem suporta daca n = 5, w = 3, r =3?":{options:["3","1","2","5"],answer:"2"},"La algoritmii cu mesaje de sondaj cu ecou, in cazul topologiilor de tip arbore (initiatorul fiind radacina arborelui):":{options:["Mesajele de sondaj se propaga de la radacina la frunze / Mesajele de ecou se propaga de la initiator la frunze","Mesajele de sondaj se propaga de la frunze la initiator / Mesajele de ecou se propaga de la initiator la frunze","Mesajele de sondaj se propaga de la radacina la frunze / Mesajele de ecou se propaga de la frunze la initiator","Mesajele de sondaj se propaga de la frunze la initiator / Mesajele de ecou se propaga de la frunze la initiator"],answer:"Mesajele de sondaj se propaga de la radacina la frunze / Mesajele de ecou se propaga de la frunze la initiator"},"In algoritmul lui Huang, pentru a detecta terminarea:":{options:["se folosesc mesaje de tip marcaj","se folosesc mesaje de tip semnal","se folosesc ponderi","se folosesc mesaje de tip marcaj si semnal"],answer:"se folosesc ponderi"},"Detecția terminării folosind marcaje: Un proces porneste algoritmul de terminare:":{options:["dupa ce primeste semnal de la parinte","dupa ce primeste marcaje de la toti vecinii, mai putin parintele","dupa ce primeste marcaj de la parinte","dupa ce primeste marcaje de la toti vecinii"],answer:"dupa ce primeste marcaj de la parinte"},"Intr-un program care foloseste pthreads, daca un thread face lock de 2 ori consecutiv pe acelasi mutex, se produce un deadlock / Intr-un program multithreaded in Java, daca un thread face lock de 2 ori consecutiv pe acelasi obiect, se produce un deadlock":{options:["adevarat / adevarat","adevarat / fals","fals / fals","fals / adevarat"],answer:"adevarat / fals"},"In care din algoritmii urmatori este necesar ca inainte de terminare sa se confirme toate mesajele care au fost trimise in topologie?":{options:["Algoritmul de terminare folosind marcaje","Algorimul Dijsktra - Scholten","Tehnica jetoanelor"],answer:"Algorimul Dijsktra - Scholten"},"Care dintre următoarele NU reprezintă un tip de consistență?":{options:["eventual consistency","distributed consistency","strong consistency","weak consistency"],answer:"distributed consistency"},"Ce inseamna scalabilitate buna in programarea paralela?":{options:["Un program nu poate fi rulat pe mai multe thread-uri","Un program poate fi rulat pe mai multe thread-uri","Pe masura ce numarul de thread-uri pe care se executa un program creste, durata de rulare scade","Pe masura ce numarul de thread-uri pe care se executa un program creste, durata de rulare creste"],answer:"Pe masura ce numarul de thread-uri pe care se executa un program creste, durata de rulare scade"},"In recuperarea de eroare, prin efectul domino:":{options:["procesele se vor sincroniza rand pe rand","sistemul distribuit esueaza si e nevoie sa se restarteze","procesele revin la starea initiala, pierzand progresul realizat pana la aparitia erorii"],answer:"procesele revin la starea initiala, pierzand progresul realizat pana la aparitia erorii"},"Un program ce foloseste MPI se compileaza folosind mpicc / Un program ce foloseste Pthread se compileaza folosind gcc":{options:["adevarat / fals","adevarat / adevarat","fals / adevarat","fals / fals"],answer:"adevarat / adevarat"},"Stabilirea empirica a scalabilitatii unei implementari presupune:":{options:["Rularea programului cu input-uri de dimensiuni diferite si urmarirea timpului de executie pentru 1 thread.","Rularea de un numar mare de ori a programului pentru a vedea daca da acelasi rezultat.","Rularea cu numar diferit de thread-uri/procese si urmarirea timpului de executie.","Rularea programului serial pe o masina cu foarte multe CPU-uri pentru a vedea efectul vectorizarilor efectuate de compilator."],answer:"Rularea cu numar diferit de thread-uri/procese si urmarirea timpului de executie."},"Ce poate cauza un comportament nedeterminist al unui program paralel?":{options:["Citirea simultana de catre doua thread-uri a aceleiasi zone de memorie","Un apel al functiei sleep","Folosirea unei regiuni critice","Scrierea simultana a doua thread-uri in aceeasi zona de memorie"],answer:"Scrierea simultana a doua thread-uri in aceeasi zona de memorie"},"Ce face aplicatia mpirun?":{options:["Porneste un program distribuit MPI","Porneste cate o aplicatie MPI pe fiecare sistem disponibil","Porneste un program MPI multi-thread","Alearga MPI-ul"],answer:"Porneste un program distribuit MPI"},"Care este avantajul crearii unui thread in Java prin implementarea interfetei Runnable?":{options:["Ne permite sa mostenim o alta clasa din clasa noastra","Viteza de rulare a thread-ului este mai mare","Nu exista avantaje","Avem mai putine metode de implementat in clasa noastra"],answer:"Ne permite sa mostenim o alta clasa din clasa noastra"},"Ce reprezinta accesul concurent la o variabila x?":{options:["Doua sau mai multe thread-uri acceseaza variabila in acelasi timp","Variabila este refolosita in acelasi cod","Nu putem avea acces concurent la o variabila","Un singur thread acceseaza variabila de mai multe ori in cadrul executiei sale"],answer:"Doua sau mai multe thread-uri acceseaza variabila in acelasi timp"},"Ce face MPI_Barrier?":{options:["Sincronizeaza threadurile asociate unui proces","Sincronizeaza procesele dintr-un comunicator","Este echivalentul unui mutex in MPI","Sincronizeaza threadurile dintr-un comunicator"],answer:"Sincronizeaza procesele dintr-un comunicator"},"Care dintre urmatoarele variante nu este o proprietate a algoritmilor de unda?":{options:["Tranzitivitate","Consistență","Terminare","Decizie"],answer:"Tranzitivitate"},"Ce face MPI_Finalize?":{options:["Determina rangul procesului curent","Initializeaza un program distribuit","Determina numarul de procese","Termina un program distribuit"],answer:"Termina un program distribuit"},"Ce face MPI_Init?":{options:["Determina numarul de procese","Initializeaza un program distribuit","Determina rangul procesului curent","Termina un program distribuit"],answer:"Initializeaza un program distribuit"},"Cum este definita eficienta paralela ( E )? Se considera T - Timpul total necesar execuției algoritmului paralel; P - Numărul de procesoare utilizate G =Timp execuție cel mai rapid algoritm secvențial":{options:["T * P","G * P / T","G / (T * P)","T * P / G"],answer:"G / (T * P)"},"Cine controleaza numarul de thread-uri pornite intr-un program Pthread?":{options:["Sistemul de Operare","Procesul","Programatorul","Linia de comanda"],answer:"Programatorul"},"Considerând următorul pseudo-cod:chan Can (int);process P1{ int v1 =0;\t\t v1+=7;            (ev1)                      send Can(v1);     (ev2)  v1+=8;}                 (ev 3)                        process P2{ int v2 =0;v2++;                     (ev4)receive Can(v2);          (ev5)v2+=10;}                 (ev 6)   Se poate garanta ca pentru orice execuție:":{options:["ev1 -> ev5","ev1 -> ev4","ev3 -> ev6","ev2 -> ev4"],answer:"ev1 -> ev5"},"Cum se poate masura timpul de executie din linia de comanda?":{options:["Folosind programul time","Folosind apel la functia localtime","Folosind programul date","Pornind aplicatia xclock"],answer:"Folosind programul time"},"In Java nu se poate folosi pentru sincronizare:":{options:["O instanta a unui obiect diferit de cel care obtine lock-ul","O clasa","Instanta curenta a obiectului care obtine lock-ul","Un tip de date primitiv"],answer:"Un tip de date primitiv"},"Cine decide pe ce core va rula un anumit thread?":{options:["Thread-ul in sine","Nu decide nimeni, se alege aleator","Procesorul","Sistemul de operare"],answer:"Sistemul de operare"},"Care dintre urmatoarele operatii creeaza o conditie de cursa atunci cand este apelata simultan de mai multe thread-uri?":{options:["Scrierea aceleiasi constante intr-o variabila","Inmultirea cu 3 a unei variabile","Efectuarea operatiei a = 0","Citirea unei variabile"],answer:"Inmultirea cu 3 a unei variabile"},"In cazul problemei Reginelor (pentru 4 regine), solutia 0 2 1 3":{options:["este invalida: conflict pe coloana","este valida","este invalida: conflict pe diagonala","este invalida: conflict pe linie"],answer:"este invalida: conflict pe diagonala"},"Care este eficienta pentru sortarea Parallel Rank Sort in cazul rularii pe P procesoare? Se considera N dimensiunea vectorului de sortat":{options:["logP","logN","logN/N","logN/P"],answer:"logN/N"},"Orice algoritm poate fi paralelizat / Pentru orice algoritm paralel, cresterea numarului de procesoare ale sistemului duce la un timp de executie mai bun":{options:["A / A","A / F","F / A","F / F"],answer:"F / F"},"Ce reprezinta Producer - Consumer?":{options:["O problema de consens","Un algoritm de unda","O problema de sincronizare","Un algoritmi de terminare a programelor distribuite"],answer:"O problema de sincronizare"},"Un program poate folosi un procesor cu 4 nuclee fizice la maxim daca este:":{options:["Single-threaded","Paralelizat pe 3 thread-uri","Paralelizat pe cel putin 4 thread-uri","Paralelizat pe 2 thread-u"],answer:"Paralelizat pe cel putin 4 thread-uri"},"Fie o variabila globala a initializata cu 0 si doua thread-uri care executa (fara sincronizare) operatia a = a + 2. Considerand ca operatia de scriere in memorie este atomica, multimea completa de valori pe care le poate avea variabila in urma executiei ambelor thread-uri este:":{options:["{2, 4}","{0, 2, 4}","{4}","{0, 4}"],answer:"{2, 4}"},"Care este eficienta pentru inmultirea a doua matrici NxN in cazul rularii pe P procesoare?":{options:["1","1 / P","N / P","1 / N"],answer:"1"},"În algoritmul Dijkstra-Scholten, deficitul unei legături înseamnă:":{options:["diferența dintre numărul de mesaje de date transmise şi numărul de semnale de confirmare primite pe acea legătură","diferența dintre numărul de mesaje de marcaj transmise și numărul de semnale de confirmare primite pe acea legătură","cardinalitatea mulțimii proceselor q pentru care fiecare vecin r are un eveniment care precede cel mai recent eveniment în p","cardinalitatea mulțimii proceselor q pentru care un eveniment în q precede cel mai recent eveniment în p"],answer:"diferența dintre numărul de mesaje de date transmise şi numărul de semnale de confirmare primite pe acea legătură"},"Ce se va intampla daca porniti un program Pthread cu mai multe thread-uri decat core-uri?":{options:["Programul va functiona normal","Programul nu compileaza","Programul porneste si creste automat numarul de core-uri","Programul nu va putea porni"],answer:"Programul va functiona normal"},'Considerati "Algoritmul cu mesaje de sondaj cu ecou" aplicat pe o topologie ce contine cicluri.Un nod (proces) oarecare va primi mai mult de 2 mesaje de  tip sondaj ...':{options:["Mereu","E posibil","Niciodata"],answer:"E posibil"},"In detectia terminarii folosind tehnica jetoanelor, cazul general, este necesara gasirea apriori a unui":{options:["ciclu care include toate nodurile grafului","diametrul grafului","ciclu care include toate arcele grafului","ciclu Hamiltonian pe graf"],answer:"ciclu care include toate arcele grafului"},"Considerati doua evenimente si ceasurile logice ale lor (momentele de producere). Constatati ca puteti ordona numeric cl(a) < cl(b). Ce puteti spune despre cele doua evenimente a si b?":{options:["Nici una dintre celelalte variante","Evenimentul a s-a petrecut inaintea evenimentului b","Evenimentul b s-a petrecut inaintea evenimentului a","Daca cele doua evenimente apartin a doua procese diferite, atunci evenimentul a s-a petrecut inaintea evenimentului b"],answer:"Nici una dintre celelalte variante"},"Care dintre urmatoarele NU este un interactive consistency conditions pentru problema generalilor bizantini":{options:["Toti Locotenentii se supun aceluiasi ordin","Toti Locotenentii loiali se supun aceluiasi ordin","Daca generalul comandant este loial, atunci toti locotenentii loiali se supun aceluiasi ordin","Daca generalul comandant este loial, atunci fiecare locotenent loial se supune ordinului generalului comandant"],answer:"Toti Locotenentii se supun aceluiasi ordin"},"In standardul MPI, MPI_COMM_WORLD este":{options:["Biblioteca","Proces","Comunicator","Functie"],answer:"Comunicator"},"Ce ne spune Legea lui Amdahl":{options:["Nu exista algoritmi perfect scalabili","Chiar si cu un numar foarte mare de procesoare, Speedup-ul este limitat la maxim fractia de timp al executiei partii de cod non-paralelizabile","In cazul paralelizarii unui algoritm, Speedup-ul trebuie sa fie superliniar","FalseTimpul total al unei aplicatii paralele este mereu mai mic decat timpul de executie al partii din cod non-paralelizabile"],answer:"Chiar si cu un numar foarte mare de procesoare, Speedup-ul este limitat la maxim fractia de timp al executiei partii de cod non-paralelizabile"},"In cazul Blockchain, consistenta si implicit corectitudinea tranzactiilor sunt asigurate de":{options:["Vanzatorul trebuie sa fie sigur ca intreaga retea o confirma","strong consistency - vanzatorul trebuie sa fie sigur ca intreaga retea confirma o tranzactie","strong consistency - cine inregistreaza o tranzactie trebuie sa ateste ca cel putin 51% dintre noduri au confirmat adaugarea acesteia","eventual consistency - dupa un timp nodurile vor actualiza oricum informatia","operatia de creare de blocuri este costisitoare si nodurile sunt obligate sa comute pe blockchain-ul cel mai lung (blockchain fork) anuland astfel eventuale tranzactii false"],answer:"operatia de creare de blocuri este costisitoare si nodurile sunt obligate sa comute pe blockchain-ul cel mai lung (blockchain fork) anuland astfel eventuale tranzactii false"},"Ce face functia pthread_join()?":{options:["Blocheaza thread-ul curent in asteptarea thread-ului dat ca argument","Opreste toate thread-urile","Intrerupe thread-ul dat ca argument","Opreste thread-ul dat ca argument"],answer:"Blocheaza thread-ul curent in asteptarea thread-ului dat ca argument"},"In Java, pentru a astepta terminarea unui thread t creat in thread-ul principal. folosim":{options:["t.start()","t.run()","t.join()","t.notify()"],answer:"t.join()"},'Care dintre urmatoarele caracterizeaza modelul de consistenta "Monotonic read consistency"':{options:["Sistemul granteaza serializarea scrierilor de catre acelasi proces","Procesele aflate sub o relatie cauzala vor vedea date consistente","Daca un process a vazut o valoare particulara a unei date, orice procese subsecvente nu vor returna valori mai vechi","Un proces ce va accesa datele anterior scrise de el nu va vedea vreodata o valoare neactualizata"],answer:"Daca un process a vazut o valoare particulara a unei date, orice procese subsecvente nu vor returna valori mai vechi"},"La initierea unei bariere in pthread este obligatoriu sa se specifice":{options:["Cate procesoare exista pe masina locala","ID-ul unui thread master ce va fi primul deblocat din apelul pthread_barrier_wait()","Numarul de thread-uri ce vor astepta la bariera","Timpul minim pentru care orice thread va fi blocat la apelul pthread_barrier_wait()"],answer:"Numarul de thread-uri ce vor astepta la bariera"},"Care din urmatoarele este un efect al unei bariere":{options:["Un thread care ajunge la o bariera trece intotdeauna imediat mai departe","Mai multe thread-uri nu pot rula simultan o bucata de cod delimitate de doua bariere","Operatiile de dupa bariera devin atomice","Tot codul de dinainte de bariera se executa de catre toate thread-urile inainte de tot codul de dupa bariera"],answer:"Tot codul de dinainte de bariera se executa de catre toate thread-urile inainte de tot codul de dupa bariera"},"Ce complexitate are Odd Even Transposition Sort pentru n=p (unde n este numarul de elemente de sortat si p este numarul de thread-uri)?":{options:["O(NlogN)","O(N^2)","O(N)","O(logN)"],answer:"O(N)"},"In distributie, conform cu modelul Foster, timpul total se calculeaza ca":{options:["suma timpului de comunicare intra-procesor, de calcul si idle pe fiecare procesor","suma timpului de comunicare inter-procesor, de calcul si idle pe fiecare proces","suma timpului de calcul si de comunicare inter-procesor pe fiecare procesor","suma timpului de comunicare, de calcul si idle pe fiecare proces"],answer:"suma timpului de comunicare, de calcul si idle pe fiecare proces"},"Intr-un sistem e-commerce (e.g. Amazon, e-Bay, etc) care sunt optiunile pe care NU e nevoie sa le consideram cand alegem intre consistenta si disponibilitate?":{options:["Tipuri de date diferite (e.g. shopping cart, billing, product etc)","Specificul organizatiei care dezvolta solutia tehnologica","Tipuri diferite de operatii (e.g. query, purchase, etc)","Tipuri diferite de servicii (e.g. distributed locks, DNS, etc)"],answer:"Specificul organizatiei care dezvolta solutia tehnologica"},"In implementare unui semafor distribuit, de ce aveti nevoie sa folositi operatii de broadcast?":{options:["Pentru ca avem nevoie sa descoperim prin relatia de cauzalitate valorile de ceas logic curente pentru a ordona folosind aceleasi momente operatiile asupra semaforului","Pentru ca unele mesaje pot fi distorsionate de atacatori malitiosi","Pentru ca avem nevoie sa asiguram participarea tuturor proceselor distribuite","Pentru ca unele mesaje se pot pierde in tranzit si avem nevoie de siguranta in comunicatie"],answer:"Pentru ca avem nevoie sa descoperim prin relatia de cauzalitate valorile de ceas logic curente pentru a ordona folosind aceleasi momente operatiile asupra semaforului"},"Intr-un ExecutorService, shutdown() permite task-urilor active sa-si termine executia / shutdownNow() opreste imediat executia task-urilor active":{options:["adevarat/adevarat","fals/fals","adevarat/fals","fals/adevarat"],answer:"adevarat/adevarat"},"Un mecanism din Java prin care putem planifica task-uri (sub forma de obiecte Runnable) se numeste:":{options:["ExecutorService","ReentrantLock","Lock","Semaphore"],answer:"ExecutorService"},"Ce se intampla la defectarea liderului in cazul algoritmului Raft":{options:["Daca un nod follower nu mai primeste mesaje heartbeat, acesta ii ia locul si anunta vecinilor noua identitate","Sunt comise toate intrarile din Log pentru a initia un proces de votare","Daca un nod follower nu mai primeste mesaje heartbeat, presupune ca leader-ul s-a defectat si initiaza o alegere",'Inregistram toate scrierile acestuia intr-un "indexed log", pe care il replicam'],answer:"Daca un nod follower nu mai primeste mesaje heartbeat, presupune ca leader-ul s-a defectat si initiaza o alegere"},"Care din variantele specificate nu este un tip predefinit de date in MPI":{options:["MPI_VECTOR","MPI_FLOAT","MPI_LONG_DOUBLE","MPI_BYTE"],answer:"MPI_VECTOR"},"Care este numarul necesar de bariere pentru calculul sumelor prefix in paralel, pe o arhitectura MIMD?":{options:["1","0","2","3"],answer:"2"},"MPI_Recv este un apel blocant / MPI_Send NU este un apel blocant in conditii normale":{options:["Adevarat / Fals","Fals / Adevarat","Adevarat / Adevarat","Fals / Fals"],answer:"Adevarat / Adevarat"},"Care din optiunile de mai jos NU este o varianta pentru faza a doua din sortarea folosind un pipeline?":{options:["fiecare procesor incepe sa transmita spre dreapta imediat ce nu mai primeste o valoare dinspre stanga","cunoscand pozitia sa din vector si numarand valorile inspectate, fiecare procesor calculeaza momentul cand incepe sa transmita spre stanga","fiecare procesor incepe sa transmita spre stanga, imediat ce numerele sunt sortate","fiecare procesor incepe sa transmita spre stanga imediat ce nu mai primeste o valoare dinspre stanga"],answer:"fiecare procesor incepe sa transmita spre dreapta imediat ce nu mai primeste o valoare dinspre stanga"},"Algoritmul cu mesaje de sondaj cu ecou":{options:["poate fi folosit doar pe topologii inel","poate fi folosit doar pe topologii arbore si nu poate fi generalizat","nu conteaza topologia","poate fi folosit pe topologii arbore, dar si generalizat pe topologii graf"],answer:"poate fi folosit pe topologii arbore, dar si generalizat pe topologii graf"},"Cati pasi sunt necesari pentru calculul sumei elementelor unui vector de dimensiune N folosind sume prefix, daca presupunem ca avem sup(N/2) procesoare":{options:["N","sup(logN)","sup(logN / N)","sup(N / 2)"],answer:"sup(logN)"},"Care este timpul de executie in cazul descompunerii distribuite uni-dimensionale pe randuri a problemei lui Floyd de aflare a drumului minim? Se considera o matrice N * N si P procese, t_msh este timpul de transmitere a unui mesaj (o linie din matrice) catre urmatorul proces destinatie, iar t_iteratie este timpul necesar pentru o iteratie.for (k = 0 to N-1)for (i = local_i_start to local_i_end)for(j = 0 to N-1)I[i,j]k+1 = min(I[i,j]k + I[k,j]k)":{options:["t_iteratie*(N^3)/P + NlogP","t_iteratie*(N^3)/P+logP*t_msg","t_iteratie*(N^3)/P + N*logP*t_msg","t_iteratie*(N^3) / P + N * t_msg"],answer:"t_iteratie*(N^3)/P + N*logP*t_msg"},"Care dintre variantele de mai jos este un algoritm de consens":{options:["Djikstra-Scholten","Raft","Dekker","Huang"],answer:"Raft"},"Care este diferenta dintre replicare sincrona cu un lider si replicare asincrona cu un lider?":{options:["La replicarea sincrona, liderul ii confirma utilizatorului fiecare scriere. La cea asincrona, liderul nu-i confirma utilizatorului niciodata scrierile","La replicarea sincrona, liderul ii confirma utilizatorului fiecare scriere. La cea asincrona, liderul nu-i confirma utilizatorului scrierile decat la anumite intervale regulate","La replicarea sincrona, liderul trimite mesajul catre urmaritor, dar nu asteapta confirmare. La cea asincrona, liderul asteapta confirmare de la urmaritor ca scrierea a fost facuta inainte sa-i confirme utlizatorului scrierea","La replicarea sincrona, liderul asteapta confirmarea de la urmaritor ca scrierea a fost facuta inainte sa-i confirme utilizatorului scirerea. La cea asincrona, liderul trimite mesajul catre urmaritor, dar nu asteapta confirmare"],answer:"La replicarea sincrona, liderul asteapta confirmarea de la urmaritor ca scrierea a fost facuta inainte sa-i confirme utilizatorului scirerea. La cea asincrona, liderul trimite mesajul catre urmaritor, dar nu asteapta confirmare"},"Care este Speedup-ul pentru algoritmul de sortare OETS? Considerati N dimensiunea vectorului de sortat si P unitati de procesare":{options:["P","(logN * P)/N","N"],answer:"(logN * P)/N"},"Care afirmatie este caracteristica pentru conceptul de blockchain fork?":{options:["Un nod onest notificat de un blockchain mai lung trebuie sa comute pe folosirea acestuia imediat","Doua tranzactii ce consuma aceiasi sursa de intrare (cineva vinde pe aceiasi bani de doua ori) - doar prima tranzactie poate fi valida","Orice hash SHA256 al unui bloc trebuie sa inceapa cu un anumit numar de zero-uri, altfel nodurile oneste il vor rejecta","Un log replicat al tuturor tranzactiilor bitcoin de la inceputul timpului"],answer:"Un nod onest notificat de un blockchain mai lung trebuie sa comute pe folosirea acestuia imediat"},"In cazul cautarii binare paralele folosind P thread-uri, complexitatea pentru citirea valorii de cautat x intr-un sistem SIMD - CREW este":{options:["O(PlogP)","O(P)","O(logP)","1"],answer:"1"},"Care este complexitatea Parallel Merge Sort, pentru P=N (atentie exista si varianta FARA P=N)":{options:["O(N*logN)","O(N^2)","O(logN)","O(N)"],answer:"O(N)"},"Problema de sincronizare East-West Bridge poate fi rezolata folosind idea de rezolvare de la":{options:["Problema Producator-Consumator","Problema Cititori-Scriitori","Problema Filozofilor","Problema Barbierului"],answer:"Problema Cititori-Scriitori"},"Problema East-West Bridge este un exemplu particular al problemei":{options:["Cigarette Smokers","Barbierului","Multiple Readers Multiple Writers","Filozofilor"],answer:"Multiple Readers Multiple Writers"},"Problema comis voiajorului foloseste codificarea":{options:["cu lista de reguli","binara","cu numere reale","permutare"],answer:"permutare"},"Care este complexitatea inmultirii a doua matrice patratice in paralel (unde N * N este numarul de elemente ale matricei, iar P este numarul de thread-uri)?":{options:["O(N^3 / P)","O(N^2 / P)","O(N)","O(N * P)"],answer:"O(N^3 / P)"},"Ce face o bariera?":{options:["Separa codul in bucati","Blocheaza thread-urile o perioada scurta de timp","Blocheaza thread-ul curent pana ce un numar dat de thread-uri ajunge la ea","Forteaza reactivarea unui thread blocat pe o resursa"],answer:"Blocheaza thread-ul curent pana ce un numar dat de thread-uri ajunge la ea"},"In cazul algoritmului unda de tip ecou cu N noduri, timpul de executie este:":{options:["O(logN)","O(N ^ 2)","O(1)","O(N)"],answer:"O(N)"},"In domeniul tolerantei la defecte in sisteme distribuite, ce inseamna un proces orfan?":{options:["Procesul init din Linux","Un proces care depinde de o stare ne-recuperabila a unui proces esuat","Un proces al carui parinte s-a oprit din functionare","Un proces oarecare"],answer:"Un proces care depinde de o stare ne-recuperabila a unui proces esuat"},"Care este limita superioara pentru eficienta pe care o puteti atinge prin paralelizare?":{options:["1","O(P / N)","O(P)","O(N)"],answer:"1"},"Care este eficienta pentru Odd Even Transposition Sort in cazul rularii pe P procesoare (unde N este dimensiunea vectorului de sortat)?":{options:["logN","logN / N","logP","logN / P"],answer:"logN / N"},"Numarul de mesaje pentru algoritmul LeLann cu N noduri este:":{options:["O(N ^ 4)","O(N ^ 3)","O(N ^ 2)","O(N)"],answer:"O(N ^ 2)"},"Ce reprezinta o regiune critica?":{options:["O sectiune de cod care poate fi accesata doar de un singur thread la acelasi moment de timp","O sectiune de cod intensiva computational","O sectiune de cod care poate fi accesata de mai multe thread-uri la acelasi moment de timp","Acest concept nu exista"],answer:"O sectiune de cod care poate fi accesata doar de un singur thread la acelasi moment de timp"},"Selectia care are la baza clasamentul indivizilor, in functie de un rang numeric, se numeste":{options:["Selectie Elitista","Selectie Ruleta","Selectie Rank","Selectie Turneu"],answer:"Selectie Rank"},"Care este eficienta pentru sortarea OETS in cazul rularii pe P procesoare? Se considera N dimensiunea vectorului de sortat":{options:["logN/P","logN","logP","logN/N"],answer:"logN/N"}};

var COMPLEXITY = 
["Care este Speedup-ul pentru algoritmul de sortare OETS? Considerati N dimensiunea vectorului de sortat si P unitati de procesare",
"Care este complexitatea temporala a difuzarii paralele a unei valori, pentru P = N / 2?",
"In cazul algoritmului unda de tip ecou cu N noduri, timpul de executie este:",
"Care este eficienta pentru sortarea Parallel Rank Sort in cazul rularii pe P procesoare? Se considera N dimensiunea vectorului de sortat",
"Care este numarul de mesaje pentru algoritmul LeLann-Chang-Robert, cazul cel mai bun (Procesele sunt ordonate crescator in sensula celor de ceasornic)? Obs.: Toate procesele sunt initiatoare.",
"Numarul de mesaje pentru algoritmul LeLann-Chang-Robert, cazul cel mai defavorabil, este: (atentie exista si cu cazul favorabil)",
"In cazul algoritmului arbore de alegere a liderului, numărul de mesaje trimise in sistem este:",
"Care este complexitatea inmultirii a doua matrici in paralel?",
"Ce complexitate are cautarea paralela pe un vector cu N elemente si un sistem cu N/2 procesoare?",
"Algoritmul Pulsatiilor: Care este complexitatea in timp?",
"Care este costul pentru Cautarea binara Paralela -  varianta 2 (original pentru SIMD - CREW) ?",
"Care este complexitatea pentru a calcula (eficient) in paralel distanta din fiecare punct al unei liste pana la sfarsitul acesteia? Lista are N elemente.",
"In cazul cautarii binare paralele folosind P thread-uri, complexitatea pentru citirea valorii de cautat x intr-un sistem SIMD - CREW este",
"Care este timpul de executie in cazul descompunerii distribuite uni-dimensionale pe randuri a problemei lui Floyd de aflare a drumului minim? Se considera o matrice N * N si P procese, t_msh este timpul de transmitere a unui mesaj (o linie din matrice) catre urmatorul proces destinatie, iar t_iteratie este timpul necesar pentru o iteratie.for (k = 0 to N-1)for (i = local_i_start to local_i_end)for(j = 0 to N-1)I[i,j]k+1 = min(I[i,j]k + I[k,j]k)",
"Numarul de mesaje pentru algoritmul LeLann cu N noduri este:",
"Care este eficienta pentru Odd Even Transposition Sort in cazul rularii pe P procesoare (unde N este dimensiunea vectorului de sortat)?",
"Care este rezultatul operației de Crossover in doua puncte, după poziția a4a si a9a pentru următorii 2 cromozomi:Cromozom1: 1101 | 00100 | 110100Cromozom2: 1010 | 11000 | 011110",
"Cum este definita eficienta paralela ( E )? Se considera T - Timpul total necesar execuției algoritmului paralel; P - Numărul de procesoare utilizate G =Timp execuție cel mai rapid algoritm secvențial",
"Care este complexitatea Parallel Merge Sort? (atentie exista si varianta P=N)",
"Numarul de mesaje pentru algoritmul LeLann-Chang-Robert, cazul cel mai favorabil, este: (atentie exista si cu cazul DEfavorabil)",
"Numarul de mesaje pentru algoritmul Hirschberg-Sinclair, cazul cel mai defavorabil, este:",
"In cautarea binara in varianta paralela (solutia optimizata), numarul de pasi (sau iteratii) necesari acoperirii intregului vector se face cautarea (notat cu g) este:",
"Numarul de mesaje pentru algoritmul LeLann este:",
"In cazul algoritmului unda de tip arbore cu N noduri, numărul de mesaje trimise in sistem este:",
"Care este complexitatea (dpdv al numarului de mesaje transmise) algoritmului arbore de alegere a liderului cu N procese?",
"Ce complexitate are Odd Even Transposition Sort pentru n=p (unde n este numarul de elemente de sortat si p este numarul de thread-uri)?",
"In cazul algoritmului unda de tip inel cu N noduri, timpul de execuție este:",
"Care este complexitatea Parallel Merge Sort, pentru P=N (atentie exista si varianta FARA P=N)",
"Pentru analiza unui algoritm paralel consideram: P=numar procesoare, T=timpul de executie a algoritmului paralel si G=timpul celui mai rapid algoritm secevential. Costul (C) reprezinta:",
"Cati pasi sunt necesari pentru calculul sumei elementelor unui vector de dimensiune N folosind sume prefix, daca presupunem ca avem sup(N/2) procesoare",
"Care este complexitatea de difuzare a unei valori intr-un sistem SIMD - EREW cu P procesoare?",
"Care este limita superioara pentru eficienta pe care o puteti atinge prin paralelizare?",
"Care este eficienta pentru inmultirea a doua matrici NxN in cazul rularii pe P procesoare?",
"Care este complexitatea algoritmului de Căutare binara paralela in sistemele SIMD - EREW (Exclusive Read Excusilve Write)? Se considera P procesoare si o secvență ordonata de N numere.",
"Care este complexitatea inmultirii a doua matrice patratice in paralel (unde N * N este numarul de elemente ale matricei, iar P este numarul de thread-uri)?",
"In cazul algoritmului unda de tip arbore cu N noduri, timpul de execuție este:",
"Care este eficienta pentru sortarea OETS in cazul rularii pe P procesoare? Se considera N dimensiunea vectorului de sortat"]


        function insertFilterButtons(chunkSize) {
            let questionsNumber = Object.keys(QUESTIONS).length;

            let rowDiv = document.createElement("div")
            rowDiv.classList.add("row", "filterDiv");

            for (let i = 0; i < questionsNumber; i += chunkSize) {
                let colDiv = document.createElement("div");
                colDiv.classList.add("col-xs-4", "filterDiv");
                
                let intervalButton = document.createElement("button");
                intervalButton.classList.add("btn", "btn-block", "btn-primary", "filterButton");
                intervalButton.setAttribute("start", i);
                intervalButton.setAttribute("end", i + chunkSize < questionsNumber ? i + chunkSize : questionsNumber);

                intervalButton.textContent = (i + 1).toString() + "-" + (i + chunkSize < questionsNumber ? i + chunkSize : questionsNumber).toString()
                colDiv.appendChild(intervalButton);
                rowDiv.appendChild(colDiv);
            }
            document.body.appendChild(rowDiv);
        }

        function insertComplexityFilterButton() {
            let questionsNumber = COMPLEXITY.length;

            let rowDiv = document.querySelector('div.row')

            let colDiv = document.createElement("div");
            colDiv.classList.add("col-xs-4", "filterDiv");
                
            let intervalButton = document.createElement("button");
            intervalButton.classList.add("btn", "btn-block", "btn-danger", "filterComplexityButton");
            intervalButton.setAttribute("start", 0);
            intervalButton.setAttribute("end", COMPLEXITY.length);

            intervalButton.textContent = "complexitati, mesaje, eficienta"
            colDiv.appendChild(intervalButton);
            rowDiv.appendChild(colDiv);
        }

        /* Returns an array of strings */
        function getShuffledQuestionKeys(idxStart, idxEnd) {
            /* since ES2015 strings are sorted chronologically,
             not alphabetically, so order is always preserved */
            let questionsKeys = Object.keys(QUESTIONS);
            if (idxStart !== undefined && idxEnd != undefined)
                questionsKeys = questionsKeys.slice(idxStart, idxEnd);
            return questionsKeys.sort((a, b) => 0.5 - Math.random());
        }

        /* Returns an array of strings */
        function getShuffledOptions(options) {
            return options
                .map(value => ({ value, sort: Math.random() }))
                .sort((a, b) => a.sort - b.sort)
                .map(({ value }) => value)
        }

        function insertQuestions(idxStart, idxEnd){
            let questionNumber = 1;
            getShuffledQuestionKeys(idxStart, idxEnd).forEach(questionText => {
                let quizBoxDiv = document.createElement('div')
                quizBoxDiv.classList.add('quizBox');

                let questionButton = document.createElement('button');
                questionButton.classList.add("btn", "btn-block", "question");
                
                questionButton.textContent = questionNumber.toString() + ". " + questionText;
                questionNumber++;

                quizBoxDiv.appendChild(questionButton);

                getShuffledOptions(QUESTIONS[questionText].options).forEach(optionText => {
                    optionButton = document.createElement('button');
                    optionButton.classList.add("btn", "btn-block", "btn-light");
                    optionButton.textContent = optionText;
                    quizBoxDiv.appendChild(optionButton);
                });
                document.body.appendChild(quizBoxDiv);
            });
        }


        function getShuffledQuestionComplexityKeys(idxStart, idxEnd) {
            /* since ES2015 strings are sorted chronologically,
             not alphabetically, so order is always preserved */
            let questionsKeys = COMPLEXITY;
            if (idxStart !== undefined && idxEnd != undefined)
                questionsKeys = questionsKeys.slice(idxStart, idxEnd);
            return questionsKeys.sort((a, b) => 0.5 - Math.random());
        }


        function insertComplexityQuestions(idxStart, idxEnd){
            let questionNumber = 1;
            getShuffledQuestionComplexityKeys(idxStart, idxEnd).forEach(questionText => {
                let quizBoxDiv = document.createElement('div')
                quizBoxDiv.classList.add('quizBox');

                let questionButton = document.createElement('button');
                questionButton.classList.add("btn", "btn-block", "question");
                
                questionButton.textContent = questionNumber.toString() + ". " + questionText;
                questionNumber++;

                quizBoxDiv.appendChild(questionButton);

                getShuffledOptions(QUESTIONS[questionText].options).forEach(optionText => {
                    optionButton = document.createElement('button');
                    optionButton.classList.add("btn", "btn-block", "btn-light");
                    optionButton.textContent = optionText;
                    quizBoxDiv.appendChild(optionButton);
                });
                document.body.appendChild(quizBoxDiv);
            });
        }

        insertFilterButtons(20);
        insertComplexityFilterButton();
        insertQuestions();

        const onClick = (event) => {
            if (event.target.nodeName === 'BUTTON') {
                if (event.target.classList.contains("filterButton")) {
                    [].forEach.call(document.querySelectorAll('.quizBox'),function(e){
                         e.parentNode.removeChild(e);
                    });
                    insertQuestions(parseInt(event.target.getAttribute('start')), parseInt(event.target.getAttribute('end')));
                    return;
                } 
                if (event.target.classList.contains("filterComplexityButton")) {
                    [].forEach.call(document.querySelectorAll('.quizBox'),function(e){
                         e.parentNode.removeChild(e);
                    });
                    insertComplexityQuestions(0, COMPLEXITY.length);
                    return;
                }


                if (!event.target.parentNode.hasAttribute("alreadyAnswered")) {
                    event.target.parentNode.scrollIntoView({behavior: "smooth", block: "start", inline: "nearest"});

                    let questionText = event.target.parentNode.querySelector(":nth-child(1)").textContent.trim().split('. ').slice(1).join('. ');

                    let responseText = event.target.textContent;
                    let rightAnswer = QUESTIONS[questionText].answer;
                    
                    if (rightAnswer == responseText) {
                        event.target.classList.add("btn-success")
                    } else {
                        event.target.classList.add("btn-danger");
                        let right = Array.from(event.target.parentNode.querySelectorAll('button'))
                            .find(el => el.textContent === rightAnswer)
                            right.classList.remove("btn-light");
                            right.classList.add("btn-success");
                    }
                    event.target.classList.remove("btn-light");

                }
                event.target.parentNode.setAttribute('alreadyAnswered', "true");
            }
            
        }
        window.addEventListener('click', onClick);
    }


    </script>
</body>
</html>
</html>